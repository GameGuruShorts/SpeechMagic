<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Voice Magic FPS Battle</title>
  <style>
    body {
      margin: 0; overflow: hidden; background: #111; color: white; font-family: Arial, sans-serif;
      user-select: none;
    }
    #overlay {
      position: absolute; top: 10px; left: 10px; z-index: 10;
      background: rgba(0,0,0,0.6); padding: 12px; border-radius: 8px;
      width: 320px;
    }
    button {
      font-size: 16px; padding: 8px 16px; margin-top: 5px; cursor: pointer;
      border: none; border-radius: 6px;
      background: linear-gradient(to right, #444, #222);
      color: white;
    }
    #status, #enemyHealth, #playerHealth {
      margin-top: 10px;
      font-weight: bold;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <div id="overlay">
    <h2>üé§ Voice Magic FPS Battle</h2>
    <p>Say a spell: <b>fireball</b>, <b>ice shard</b>, <b>lightning</b>, <b>wind blast</b>, <b>meteor storm</b>, <b>dragon roar</b>, <b>heal</b></p>
    <button id="castButton">üéôÔ∏è Cast Spell</button>
    <p id="status">Status: Idle</p>
    <p id="enemyHealth">Enemy Health: 100</p>
    <p id="playerHealth">Your Health: 100</p>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <script>
    // Spells data from your script
    const spells = {
      "fireball": { damage: 30, color: 0xff3300 },
      "ice shard": { damage: 20, color: 0x00ffff },
      "lightning": { damage: 40, color: 0xffff00 },
      "wind blast": { damage: 25, color: 0xffffff },
      "meteor storm": { damage: 60, color: 0xff8800 },
      "dragon roar": { damage: 80, color: 0xff00ff },
      "heal": { heal: 30, color: 0x00ff00 }
    };

    let enemyHealth = 100;
    let playerHealth = 100;

    const status = document.getElementById("status");
    const enemyHealthEl = document.getElementById("enemyHealth");
    const playerHealthEl = document.getElementById("playerHealth");
    const castButton = document.getElementById("castButton");

    // Three.js setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x202020);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 1.6, 0); // Eye height

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Lighting
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(10, 20, 10);
    scene.add(light);
    scene.add(new THREE.AmbientLight(0x404040));

    // Floor
    const floorGeo = new THREE.PlaneGeometry(100, 100);
    const floorMat = new THREE.MeshPhongMaterial({ color: 0x555555 });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI/2;
    scene.add(floor);

    // Enemy - red box
    const enemyGeo = new THREE.BoxGeometry(1, 2, 1);
    const enemyMat = new THREE.MeshPhongMaterial({ color: 0xff0000 });
    const enemy = new THREE.Mesh(enemyGeo, enemyMat);
    enemy.position.set(0, 1, -10);
    scene.add(enemy);

    // Player movement & controls variables
    const move = { forward: false, backward: false, left: false, right: false };
    let yaw = 0, pitch = 0;
    let prevTime = performance.now();
    let velocity = new THREE.Vector3();

    // Pointer lock controls for FPS mouse look
    document.body.addEventListener('click', () => {
      if (document.pointerLockElement !== renderer.domElement) {
        renderer.domElement.requestPointerLock();
      }
    });

    document.addEventListener('pointerlockchange', () => {
      if (document.pointerLockElement === renderer.domElement) {
        document.addEventListener('mousemove', onMouseMove, false);
      } else {
        document.removeEventListener('mousemove', onMouseMove, false);
      }
    });

    function onMouseMove(event) {
      const movementX = event.movementX || 0;
      const movementY = event.movementY || 0;
      yaw -= movementX * 0.002;
      pitch -= movementY * 0.002;
      pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));
    }

    // Keyboard controls
    window.addEventListener('keydown', (e) => {
      switch(e.code) {
        case 'KeyW': move.forward = true; break;
        case 'KeyS': move.backward = true; break;
        case 'KeyA': move.left = true; break;
        case 'KeyD': move.right = true; break;
      }
    });
    window.addEventListener('keyup', (e) => {
      switch(e.code) {
        case 'KeyW': move.forward = false; break;
        case 'KeyS': move.backward = false; break;
        case 'KeyA': move.left = false; break;
        case 'KeyD': move.right = false; break;
      }
    });

    // Spell projectile class
    class SpellProjectile {
      constructor(color) {
        const geom = new THREE.SphereGeometry(0.1, 8, 8);
        const mat = new THREE.MeshBasicMaterial({ color });
        this.mesh = new THREE.Mesh(geom, mat);
        this.velocity = new THREE.Vector3();
        this.alive = true;
        scene.add(this.mesh);
      }

      shoot(fromPos, direction) {
        this.mesh.position.copy(fromPos);
        this.velocity.copy(direction).multiplyScalar(0.3);
      }

      update() {
        if (!this.alive) return;
        this.mesh.position.add(this.velocity);
        // Simple collision check with enemy bounding box
        const dist = this.mesh.position.distanceTo(enemy.position);
        if (dist < 1) {
          this.alive = false;
          scene.remove(this.mesh);
          return true; // hit
        }
        // Remove if too far
        if (this.mesh.position.length() > 100) {
          this.alive = false;
          scene.remove(this.mesh);
        }
        return false;
      }
    }

    const activeProjectiles = [];

    // Update UI
    function updateUI() {
      enemyHealthEl.textContent = `Enemy Health: ${Math.max(enemyHealth, 0)}`;
      playerHealthEl.textContent = `Your Health: ${Math.max(playerHealth, 0)}`;
    }

    // Enemy attacks player every 3 seconds if alive
    function enemyAttack() {
      if (enemyHealth <= 0 || playerHealth <= 0) return;
      let damage = Math.floor(Math.random() * 15) + 5;
      playerHealth -= damage;
      status.textContent = `Enemy attacks you for ${damage}!`;
      updateUI();
      if (playerHealth <= 0) {
        status.textContent = "You were defeated! Reload page to try again.";
        castButton.disabled = true;
      }
    }
    setInterval(enemyAttack, 3000);

    // Particle effect for spells (like your original)
    function createSpellParticles(color, position) {
      const group = new THREE.Group();
      for (let i = 0; i < 30; i++) {
        const geom = new THREE.SphereGeometry(0.03, 8, 8);
        const mat = new THREE.MeshBasicMaterial({ color });
        const particle = new THREE.Mesh(geom, mat);
        particle.position.set(0, 0, 0);
        particle.velocity = new THREE.Vector3(
          (Math.random()-0.5) * 0.1,
          (Math.random()-0.5) * 0.1,
          (Math.random()-0.5) * 0.1
        );
        group.add(particle);
      }
      group.position.copy(position);
      scene.add(group);
      return group;
    }

    const spellParticleGroups = [];

    // Speech Recognition Setup
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SpeechRecognition) {
      status.textContent = "Your browser doesn't support voice recognition.";
      castButton.disabled = true;
    }

    const recognizer = new SpeechRecognition();
    recognizer.lang = "en-US";
    recognizer.interimResults = false;
    recognizer.maxAlternatives = 1;

    recognizer.onresult = (event) => {
      let spoken = event.results[0][0].transcript.toLowerCase().trim();
      status.textContent = `You said: "${spoken}"`;

      if (spoken in spells) {
        const spell = spells[spoken];

        if (spell.damage) {
          // Shoot spell projectile forward
          const spellProj = new SpellProjectile(spell.color);
          // Direction vector from camera rotation
          const dir = new THREE.Vector3(0, 0, -1);
          dir.applyEuler(new THREE.Euler(pitch, yaw, 0, 'YXZ'));
          spellProj.shoot(camera.position.clone(), dir);
          activeProjectiles.push({ proj: spellProj, damage: spell.damage });

          // Particle effect at camera position
          spellParticleGroups.push(createSpellParticles(spell.color, camera.position.clone()));

          status.textContent += ` ‚Äî ${spoken} cast!`;
        } else if (spell.heal) {
          playerHealth = Math.min(100, playerHealth + spell.heal);
          status.textContent += ` ‚Äî You heal for ${spell.heal}!`;
        }

        updateUI();

        if (enemyHealth <= 0) {
          status.textContent = "üéâ Enemy defeated! You win!";
          castButton.disabled = true;
          return;
        }
      } else {
        status.textContent += " ‚Äî Spell not recognized!";
      }
    };

    recognizer.onerror = (event) => {
      status.textContent = "Error: " + event.error;
    };

    castButton.addEventListener("click", () => {
      if (playerHealth > 0 && enemyHealth > 0) {
        status.textContent = "üé§ Listening...";
        recognizer.start();
      }
    });

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);

      // Movement speed
      const time = performance.now();
      const delta = (time - prevTime) / 1000;
      prevTime = time;

      // Calculate direction vector
      const direction = new THREE.Vector3();
      if (move.forward) direction.z -= 1;
      if (move.backward) direction.z += 1;
      if (move.left) direction.x -= 1;
      if (move.right) direction.x += 1;
      direction.normalize();

      // Calculate velocity based on direction and camera rotation
      if (direction.length() > 0) {
        const moveDir = new THREE.Vector3();
        moveDir.copy(direction).applyEuler(new THREE.Euler(0, yaw, 0));
        velocity.copy(moveDir).multiplyScalar(5 * delta);
        camera.position.add(velocity);
      }

      // Apply camera rotation from yaw and pitch
      camera.rotation.set(pitch, yaw, 0);

      // Update enemy to face player
      enemy.lookAt(camera.position);

      // Update active projectiles
      for (let i = activeProjectiles.length -1; i >= 0; i--) {
        const {proj, damage} = activeProjectiles[i];
        const hit = proj.update();
        if (hit) {
          enemyHealth -= damage;
          updateUI();
          activeProjectiles.splice(i, 1);
          // Small flash on enemy
          enemy.material.color.set(0xffffff);
          setTimeout(() => enemy.material.color.set(0xff0000), 100);
          if (enemyHealth <= 0) {
            status.textContent = "üéâ Enemy defeated! You win!";
            castButton.disabled = true;
          }
        } else if (!proj.alive) {
          activeProjectiles.splice(i, 1);
        }
      }

      // Update spell particles
      for (let i = spellParticleGroups.length - 1; i >= 0; i--) {
        const group = spellParticleGroups[i];
        group.children.forEach(p => {
          p.position.add(p.velocity);
          p.material.opacity = (p.material.opacity || 1) - 0.02;
          if (p.material.opacity <= 0) p.visible = false;
        });
        if (group.children.every(p => !p.visible)) {
          scene.remove(group);
          spellParticleGroups.splice(i, 1);
        }
      }

      renderer.render(scene, camera);
    }

    // Initialize
    updateUI();
    let prevTime = performance.now();
    animate();
  </script>
</body>
</html>
